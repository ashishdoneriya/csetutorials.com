<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAQAAABLCVATAAAAdUlEQVR4Ae3MIRJAUBCH8e81R3AO53AmvIQmu5MzqE8iKoZAEdZYZhT7/cuGnR9/yeEJrDcW8DjEKlbFasQmFTQitj+cK2TqO8ggg2LceygiZ6YjeQel9Me10NI8ghR7DhlkkEFBxQTEShVUcVHGcAsZ8PylDecfc51kCzSlAAAAAElFTkSuQmCC type=image/x-icon><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wdth,wght@0,75..100,100..900;1,75..100,100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://csetutorials.com/scss/main.min.css><title>Understanding Git: Clone, Remotes, Branches, Rebase and Recovery</title>
<meta name=description content="Step-by-step explanation of Git commands and concepts including clone, remotes, branching, pull, rebase, forks, tracking, history cleanup and recovery."><meta name=author content="Ashish Doneriya"><meta name=robots content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><link rel=canonical href=https://csetutorials.com/git-clone-rebase-forks.html><meta property="og:type" content="article"><meta property="og:title" content="Understanding Git: Clone, Remotes, Branches, Rebase and Recovery"><meta property="og:description" content="Step-by-step explanation of Git commands and concepts including clone, remotes, branching, pull, rebase, forks, tracking, history cleanup and recovery."><meta name=keywords content="git"><meta property="og:url" content="https://csetutorials.com/git-clone-rebase-forks.html"><meta property="og:site_name" content="Cse Tutorials"><meta property="article:published_time" content="2025-06-24T08:00:00+05:30"><meta property="article:modified_time" content="2025-06-24T08:00:00+05:30"><meta property="article:author" content="Ashish Doneriya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Understanding Git: Clone, Remotes, Branches, Rebase and Recovery"><meta name=twitter:description content="Step-by-step explanation of Git commands and concepts including clone, remotes, branching, pull, rebase, forks, tracking, history cleanup and recovery."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Understanding Git: Clone, Remotes, Branches, Rebase and Recovery","description":"Step-by-step explanation of Git commands and concepts including clone, remotes, branching, pull, rebase, forks, tracking, history cleanup and recovery.","author":{"@type":"Person","name":"Ashish Doneriya"},"keywords":["\"%!s(MISSING)\""],"articleSection":["\"%!s(MISSING)\""],"datePublished":"2025-06-24T08:00:00\u002b05:30","dateModified":"2025-06-24T08:00:00\u002b05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/csetutorials.com\/git-clone-rebase-forks.html"},"url":"https:\/\/csetutorials.com\/git-clone-rebase-forks.html"}</script></head><body><nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container><a class=navbar-brand href=/>Cse Tutorials</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-end" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/about-us/>About us</a></li><li class=nav-item><a class=nav-link href=/contact-us/>Contact us</a></li><li class=nav-item><a class=nav-link href=/privacy-policy/>Privacy Policy</a></li><li class=nav-item><a class=nav-link href=/terms-of-service/>Terms of Service</a></li><li class=nav-item><a class=nav-link href=/topics/>Topics</a></li></ul></div></div></nav><main><article class=page-wrapper><h1 class="mb-4 text-center">How Git Actually Works: From Clone to Rebase, Forks, History Fixes and Recovery</h1><div class="d-flex justify-content-center align-items-center mb-4 text-muted small"><time datetime="2025-06-24 08:00:00 +0530 +0530">Jun 24, 2025</time>
<span class=mx-2>|</span>
<span>Ashish Doneriya</span>
<span class=mx-2>|</span>
<a class=text-decoration-none href=/topics/technology rel=category>technology</a></div><div class=post-content><p>Git works fine when you&rsquo;re just committing and pushing, but the moment you deal with forks, remotes, rebases, or cleaning up history, it becomes unclear what Git is actually doing. This guide explains each concept in order - what happens, why it happens, and how to use it confidently in real workflows.</p><p>We’ll begin at the very start, cloning a repository, and build up step by step from there. Here&rsquo;s everything we&rsquo;ll cover in sequence:</p><h2></h2><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#step-1-you-run-git-clone>Step 1: You run <code>git clone</code></a></li><li><a href=#step-2-what-branches-exist-after-cloning>Step 2: What branches exist after cloning?</a></li><li><a href=#step-3-what-exactly-is-originmain>Step 3: What exactly is <code>origin/main</code>?</a></li><li><a href=#step-4-what-does-git-branch--r-show>Step 4: What does <code>git branch -r</code> show?</a></li><li><a href=#step-5-what-does-git-fetch-do>Step 5: What does <code>git fetch</code> do?</a></li><li><a href=#step-6-what-does-git-merge-do>Step 6: What does <code>git merge</code> do?</a></li><li><a href=#step-7-what-does-git-rebase-do>Step 7: What does <code>git rebase</code> do?</a></li><li><a href=#step-8-what-does-git-pull-do>Step 8: What does <code>git pull</code> do?</a></li><li><a href=#step-9-what-does-git-pull---rebase-do>Step 9: What does <code>git pull --rebase</code> do?</a></li><li><a href=#step-10-what-does-git-pull-origin-mean>Step 10: What does <code>git pull origin</code> mean?</a></li><li><a href=#step-11-working-with-multiple-remotes>Step 11: Working with multiple remotes</a></li><li><a href=#step-12-what-is-branch-tracking-in-git>Step 12: What is branch tracking in Git?</a></li><li><a href=#step-13-why-you-always-push-to-origin-and-pull-from-upstream>Step 13: Why you always push to <code>origin</code> and pull from <code>upstream</code></a></li><li><a href=#step-14-syncing-a-feature-branch-with-upstreams-updated-main>Step 14: Syncing a feature branch with upstream’s updated main</a></li><li><a href=#step-15-rebasing-multiple-dependent-branches-safely>Step 15: Rebasing multiple dependent branches safely</a></li><li><a href=#step-16-splitting-a-large-branch-into-multiple-pull-requests>Step 16: Splitting a large branch into multiple pull requests</a></li><li><a href=#step-17-rewriting-commit-history-using-interactive-rebase>Step 17: Rewriting commit history using interactive rebase</a></li><li><a href=#step-18-undoing-mistakes-using-reflog-reset-and-restore>Step 18: Undoing mistakes using <code>reflog</code>, <code>reset</code>, and <code>restore</code></a></li><li><a href=#step-19-deleting-local-and-remote-branches-cleanly>Step 19: Deleting local and remote branches cleanly</a></li><li><a href=#step-20-dealing-with-diverged-branches-and-force-push>Step 20: Dealing with diverged branches and force-push</a></li><li><a href=#-git-command-summary>Git Command Summary</a></li></ul><h2></h2><h2 id=step-1-you-run-git-clone>Step 1: You run git clone</h2><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/company/project.git
</span></span></code></pre></div><p>This is the starting point. You&rsquo;re copying a project from a central server (like GitHub) to your own laptop. When you do this, Git performs several exact actions:</p><h3 id=a-creates-a-new-directory>A. Creates a new directory</h3><p>Git makes a new folder called project/ and puts all the files and internal Git data inside it.</p><h3 id=b-downloads-all-contents>B. Downloads all contents</h3><p>Git downloads:</p><ul><li>The latest snapshot of the default branch (usually main)</li><li>The entire commit history</li><li>All other branches and tags</li><li>Everything is stored inside .git/, which is a hidden folder containing Git&rsquo;s internal database</li></ul><h3 id=c-sets-up-a-remote-connection-and-names-it-origin>C. Sets up a remote connection and names it origin</h3><p>Now this part is critical:</p><ul><li>Git needs to remember where you cloned the repo from so it can pull/fetch/push code later</li><li>It saves that remote URL internally (e.g. <a href=https://github.com/company/project.git target=_blank rel="noopener nofollow">https://github.com/company/project.git</a>)</li><li>It assigns a shortcut name to this URL: origin</li></ul><p>Why this shortcut? Because Git allows multiple remotes. You could later add another one called upstream, staging, etc. Instead of typing the full URL each time, Git uses short names like:</p><ul><li>origin - the one you cloned from (default)</li><li>upstream - maybe the original repo you forked from</li><li>backup - maybe another remote server</li></ul><p>You can view or confirm this by running:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote -v
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin  https://github.com/company/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>origin  https://github.com/company/project.git <span style=color:#f92672>(</span>push<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>That means:</p><ul><li>Git knows the URL you cloned from</li><li>Git has saved it with the nickname origin</li><li>It will use that for future git fetch, git pull, and git push</li></ul><p>You can even rename it later:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote rename origin mygithub
</span></span></code></pre></div><p>But origin is the default that Git sets up when you clone.</p><h2></h2><h2 id=step-2-what-branches-exist-after-cloning>Step 2: What branches exist after cloning?</h2><p>After the clone completes, your Git repository has two types of branches stored inside:</p><h3 id=a-one-local-branch>A. One local branch</h3><p>Git checks out the default branch from the remote - usually main.</p><p>You can confirm this by running:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>* main
</code></pre><p>This is your working branch. You can:</p><ul><li>Edit files</li><li>Make commits</li><li>Switch to other branches</li><li>Push your changes later</li></ul><p>Only this branch is created locally after clone.</p><h3 id=b-multiple-remote-tracking-branches>B. Multiple remote-tracking branches</h3><p>Here comes the important part:</p><p>Git does not create local branches for all the other branches on the remote.
Instead, it creates remote-tracking branches for all of them.</p><p>You can list them using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch -r
</span></span></code></pre></div><p>Example output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin/main
</span></span><span style=display:flex><span>origin/dev
</span></span><span style=display:flex><span>origin/feature-x
</span></span></code></pre></div><p>What do these mean?</p><ul><li>These are read-only branch pointers</li><li>They show what each remote branch looked like at the time you cloned</li><li>They are stored in: <code>.git/refs/remotes/origin/</code></li><li>You cannot commit to them directly</li><li>They are updated only by git fetch or git pull</li></ul><p>They help Git remember:</p><blockquote><p>This is what I last saw on the server for each branch.</p></blockquote><p>So yes - when you clone, Git does not just get origin/main, it fetches and saves all remote branches into your local .git, under the prefix origin/.</p><h2></h2><h2 id=step-3-what-exactly-is-originmain>Step 3: What exactly is origin/main?</h2><p>This is not a local branch. It is a remote-tracking branch. Git uses this to track the last known state of the main branch on the remote server (origin). It exists only so you can compare your local work with what&rsquo;s on the remote. It is stored internally like <code>.git/refs/remotes/origin/main</code></p><p>This file contains the commit hash of the most recent commit on the remote main branch when you cloned or last fetched. This is how Git knows how far ahead or behind your local main is compared to what&rsquo;s on the server. You can&rsquo;t check out origin/main directly (without creating a new local branch), and you can&rsquo;t commit to it.</p><h2></h2><h2 id=step-4-what-does-git-branch--r-show>Step 4: What does git branch -r show?</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch -r
</span></span></code></pre></div><p>This command shows only remote-tracking branches.</p><p>That means:</p><ul><li>origin/main</li><li>origin/dev</li><li>origin/feature-x</li><li>etc.</li></ul><p>These reflect the remote-side branches Git is tracking locally - in read-only mode. They help you compare your local branches with the branches on the server. They live in <code>.git/refs/remotes/origin/</code>. Each file inside that folder contains the last known commit hash for that remote branch.</p><h2></h2><h2 id=step-5-what-does-git-fetch-do>Step 5: What does git fetch do?</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch
</span></span></code></pre></div><p>Git contacts the origin server and checks for updates on all remote branches.</p><ul><li>If any branch (e.g. main, dev, feature-x) has new commits, Git downloads those commits</li><li>Git then updates the corresponding <code>origin/&lt;branch></code> pointers</li></ul><p>That means:</p><ul><li>origin/main now points to the latest commit on GitHub&rsquo;s main</li><li>origin/dev now points to the latest commit on GitHub&rsquo;s dev</li><li>etc.</li></ul><p>Your own local branches (main, dev, etc.) are untouched. Nothing in your working directory changes. To bring updates into your local branch, you must explicitly do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git merge origin/main
</span></span></code></pre></div><p>OR</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase origin/main
</span></span></code></pre></div><p>Until then, your local code remains as-is.</p><h2></h2><h2 id=step-6-what-does-git-merge-do>Step 6: What does git merge do?</h2><p>You use git merge to bring changes from one branch into another.</p><p>Situation:</p><ul><li>You are on your local main branch</li><li>You fetched the latest from remote → so origin/main is now ahead</li><li>You want to update your branch with the new commits from origin/main</li></ul><p>Command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git merge origin/main
</span></span></code></pre></div><p>What happens:</p><ul><li>Git compares your main branch with origin/main</li><li>It creates a merge commit that combines both sets of changes</li><li>Your commit history now shows a branch-merge structure</li></ul><p>Notes:</p><ul><li>If there are no conflicting changes, the merge completes cleanly</li><li>If there are conflicts, Git will pause and ask you to resolve them manually, then commit</li></ul><h2></h2><h2 id=step-7-what-does-git-rebase-do>Step 7: What does git rebase do?</h2><p>You use git rebase to move your local commits on top of new commits from another branch.</p><p>Situation:</p><ul><li>origin/main has new commits</li><li>Your main also has new commits that aren&rsquo;t pushed yet</li><li>You want your commits to appear after the latest from the remote</li></ul><p>Command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase origin/main
</span></span></code></pre></div><p>What happens:</p><ul><li>Git re-applies your commits one by one on top of the latest origin/main</li><li>It rewrites history (commit hashes change)</li><li>Final result: linear commit history, no merge commit</li></ul><p>Key difference:</p><table><thead><tr><th>git merge</th><th>git rebase</th></tr></thead><tbody><tr><td>Keeps both histories</td><td>Makes it look like you committed after the remote did</td></tr><tr><td>Creates a merge commit</td><td>No merge commit</td></tr><tr><td>Preserves original commit IDs</td><td>Rewrites your commit IDs</td></tr></tbody></table><h2></h2><h2 id=step-8-what-does-git-pull-do>Step 8: What does git pull do?</h2><p>Git pull is a shortcut for two commands combined:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch
</span></span><span style=display:flex><span>git merge origin/&lt;your-branch&gt;
</span></span></code></pre></div><p>So:</p><ul><li>It contacts the remote</li><li>Downloads new commits</li><li>Automatically merges them into your current branch</li></ul><p>Example:</p><p>You are on main, and you run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull
</span></span></code></pre></div><p>Git will:</p><ul><li>Fetch latest changes from origin/main</li><li>Merge them into your local main</li></ul><h2></h2><h2 id=step-9-what-does-git-pull-rebase-do>Step 9: What does git pull &ndash;rebase do?</h2><p>This is like git pull, but instead of merging, it rebases your local commits on top of the remote.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull --rebase
</span></span></code></pre></div><p>It&rsquo;s a shortcut for:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch
</span></span><span style=display:flex><span>git rebase origin/&lt;your-branch&gt;
</span></span></code></pre></div><p>When to use:</p><ul><li>If you want a clean, linear history</li><li>If you haven&rsquo;t pushed your local commits yet</li><li>If your team prefers &ldquo;no merge commits&rdquo; in shared branches</li></ul><h2></h2><h2 id=step-10-what-does-git-pull-origin-mean>Step 10: What does git pull origin mean?</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull origin
</span></span></code></pre></div><p>This tells Git:</p><ul><li>Pull from the origin remote</li><li>Fetch and merge the corresponding branch for the current local branch</li></ul><p>But it still depends on the tracking configuration of your current branch.</p><p>Better form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull origin main
</span></span></code></pre></div><p>This is explicit. It means:</p><blockquote><p>Pull from remote origin, branch main, into my current branch.</p></blockquote><h2></h2><h2 id=step-11-working-with-multiple-remotes>Step 11: Working with multiple remotes</h2><p>Use case:</p><p>You fork a project. Now you have:</p><ul><li>Your GitHub repo → called origin</li><li>The original project → called upstream</li></ul><p>Add the second remote:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote add upstream https://github.com/original/project.git
</span></span></code></pre></div><p>Now check:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote -v
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin    https://github.com/yourname/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>upstream  https://github.com/original/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>To fetch new changes from upstream:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch upstream
</span></span></code></pre></div><p>This brings in:</p><ul><li>upstream/main</li><li>upstream/dev</li><li>etc.</li></ul><p>You can now merge or rebase from them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase upstream/main
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git merge upstream/main
</span></span></code></pre></div><p>You usually don&rsquo;t push to upstream. You only push to origin.</p><h2></h2><h2 id=step-12-what-is-branch-tracking-in-git>Step 12: What is branch tracking in Git?</h2><p>When you create a local branch based on a remote branch, Git can link the two together. This link is called a tracking relationship. It tells Git:</p><blockquote><p>When I run git pull, git push, or git status on this local branch - which remote branch should I compare or sync with?</p></blockquote><p>This connection saves you from typing the full remote name and branch name every time.</p><h3 id=example-1-when-you-clone-a-repo>Example 1: When you clone a repo</h3><p>You run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/company/project.git
</span></span></code></pre></div><p>Now you&rsquo;re inside the repo, and Git has automatically:</p><ul><li>Created a local branch main</li><li>Set it to track origin/main</li></ul><p>So when you run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull
</span></span></code></pre></div><p>Git already knows:</p><ul><li>Pull from origin</li><li>Use the main branch</li></ul><p>You don&rsquo;t need to type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull origin main
</span></span></code></pre></div><p>(but you still can)</p><h3 id=example-2-you-create-a-local-branch-from-a-remote-one>Example 2: You create a local branch from a remote one</h3><p>Let&rsquo;s say you want to work on the remote branch origin/dev.</p><p>You run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b dev origin/dev
</span></span></code></pre></div><p>This creates a new local branch dev, and Git automatically links it to origin/dev.</p><p>Now:</p><ul><li>dev is a normal local branch (you can edit/commit)</li><li>It tracks origin/dev</li></ul><p>Which means:</p><ul><li>git pull on dev will pull from origin/dev</li><li>git push will push to origin/dev</li><li>git status will show if your local dev is ahead or behind origin/dev</li></ul><h3 id=how-to-check-what-your-branch-is-tracking>How to check what your branch is tracking?</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch -vv
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>* dev   abc123 <span style=color:#f92672>[</span>origin/dev<span style=color:#f92672>]</span>  your commit message here
</span></span><span style=display:flex><span>  main  def456 <span style=color:#f92672>[</span>origin/main<span style=color:#f92672>]</span> another message
</span></span></code></pre></div><p>Explanation:</p><ul><li>You are currently on dev (*)</li><li>dev is linked to origin/dev</li><li>main is linked to origin/main</li></ul><h3 id=how-to-change-or-set-tracking-manually>How to change or set tracking manually</h3><p>If the link is missing or wrong, you can manually fix it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch --set-upstream-to<span style=color:#f92672>=</span>origin/dev dev
</span></span></code></pre></div><p>This tells Git:</p><blockquote><p>The dev branch should now track origin/dev.</p></blockquote><p>Now all future pull or push commands on dev will default to origin/dev.</p><h2></h2><h2 id=step-13-why-you-always-push-to-origin-and-pull-from-upstream-in-a-fork-based-setup>Step 13: Why you always push to origin and pull from upstream in a fork-based setup</h2><p>When working with a forked repository, there are two remotes involved:</p><ul><li>origin → this is your personal copy (your fork) on GitHub</li><li>upstream → this is the original repository you forked from</li></ul><p>When you clone your fork, Git sets up origin by default:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/yourname/project.git
</span></span><span style=display:flex><span>cd project
</span></span></code></pre></div><p>Now origin is set to <a href=https://github.com/yourname/project.git target=_blank rel="noopener nofollow">https://github.com/yourname/project.git</a>, and it is the only remote so far. You can verify it using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote -v
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin  https://github.com/yourname/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>origin  https://github.com/yourname/project.git <span style=color:#f92672>(</span>push<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>This means Git knows your fork&rsquo;s location and will use this for all pull/push operations unless told otherwise. You own this fork, so you can push to it freely.</p><p>Next, you add the original repository as a second remote called upstream, using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote add upstream https://github.com/company/project.git
</span></span></code></pre></div><p>Now if you run git remote -v again, you get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin    https://github.com/yourname/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>origin    https://github.com/yourname/project.git <span style=color:#f92672>(</span>push<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>upstream  https://github.com/company/project.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>You now have two remotes:</p><ul><li>origin: you can pull from and push to this</li><li>upstream: you can only pull from this (you don&rsquo;t have push permission)</li></ul><p>Suppose the original repo (upstream) has received new commits on the main branch, and you want to update your local branch to match. First, fetch those updates from upstream:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch upstream
</span></span></code></pre></div><p>This downloads all branch heads from the upstream repo. For example, it updates a remote-tracking branch called upstream/main. It does not modify your local main branch yet. To bring the upstream changes into your local main, run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git merge upstream/main
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase upstream/main
</span></span></code></pre></div><p>This updates your local main to include the latest commits from the original repo. If you&rsquo;ve made local changes, rebase re-applies them on top of upstream&rsquo;s latest commits. If you haven&rsquo;t made local changes, it simply fast-forwards.</p><p>After this, your local main is now up to date. Now you want to push your updated main branch to your own fork (origin). You do that with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin main
</span></span></code></pre></div><p>This updates the main branch in your forked repo on GitHub. You never push to upstream because you don&rsquo;t have write access. If you try:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push upstream main
</span></span></code></pre></div><p>It will fail with a permission denied error unless you&rsquo;re a maintainer of that repo.</p><p>Once your fork (origin) has the updated code, you go to GitHub and raise a pull request from your fork&rsquo;s main to the original project&rsquo;s main. That&rsquo;s the standard open-source collaboration flow:</p><ul><li>Pull from upstream</li><li>Push to origin</li><li>Create pull request from origin/main to upstream/main</li></ul><p>This keeps your fork in sync with the main project and allows your changes to be reviewed and merged.</p><h2></h2><h2 id=step-14-syncing-a-feature-branch-in-your-fork-with-upstreams-updated-main>Step 14: Syncing a feature branch in your fork with upstream&rsquo;s updated main</h2><p>Let&rsquo;s say you&rsquo;ve created a feature branch called feature/foo in your fork (origin), based on main. The upstream repo (company/project.git) has moved ahead - more commits were added to main. You now want to bring those new commits from upstream into your feature branch, without polluting the history or introducing unrelated noise.</p><p>Here&rsquo;s the correct sequence:</p><p>You already have:</p><ul><li>origin → your fork</li><li>upstream → original repo</li><li>Local branch: feature/foo (tracking origin/feature/foo)</li></ul><p>Now:</p><ol><li>Fetch the latest changes from upstream<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch upstream
</span></span></code></pre></div>This updates upstream/main locally. It doesn&rsquo;t affect any of your branches.</li><li>Switch to your feature branch<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b foo feature/foo
</span></span></code></pre></div>Make sure you&rsquo;re on the branch you want to update.</li><li>Rebase your feature branch onto upstream&rsquo;s latest main<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase upstream/main
</span></span></code></pre></div></li></ol><p>This does the following:</p><ul><li>Takes the current state of upstream/main</li><li>Re-applies your feature branch commits on top of it</li><li>Keeps history clean and avoids merge commits</li></ul><p>This makes your feature branch look like it was freshly branched from the latest upstream state.</p><p>If there are conflicts, Git pauses and lets you resolve them. After fixing each conflict:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git add &lt;file&gt;
</span></span><span style=display:flex><span>git rebase --continue
</span></span></code></pre></div><p>You repeat this until the rebase completes.</p><ol start=4><li>Push your updated feature branch to your fork</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin
</span></span></code></pre></div><p>If the rebase changed commit hashes (it always does), Git will reject a normal push. Use <code>--force-with-lease</code> or <code>--force</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push --force-with-lease origin feature/foo
</span></span></code></pre></div><p>This updates the feature/foo branch in your fork to match your rebased local branch.</p><p>Now, your feature branch is based on the latest upstream main. When you raise a pull request from feature/foo to upstream/main, your changes will cleanly sit on top of the latest upstream history.</p><blockquote><p>Use <code>--force-with-lease</code> instead of <code>--force</code> to avoid accidentally overwriting someone else’s changes on the remote. It refuses to push if the remote branch has changed since you last fetched, making it safer in team environments.</p></blockquote><h2></h2><h2 id=step-15-how-to-rebase-multiple-topic-branches-safely-when-they-depend-on-each-other>Step 15: How to rebase multiple topic branches safely when they depend on each other</h2><p>Let&rsquo;s say you&rsquo;re working on a feature that you split into three local branches, each building on top of the previous:</p><p><strong>main → feature-a → feature-b → feature-c</strong></p><p>Each branch adds new code, but feature-b depends on code in feature-a, and feature-c depends on feature-b.</p><p>Now upstream main has moved forward, and you want to rebase your entire stack of branches onto the latest upstream/main.</p><p>The key rule is:</p><p>Always rebase from the bottom up - never top-down.</p><p>Commands (assuming upstream is already set):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch upstream
</span></span></code></pre></div><p>Now rebase each branch one by one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout feature-a
</span></span><span style=display:flex><span>git rebase upstream/main
</span></span><span style=display:flex><span>git push --force-with-lease origin feature-a
</span></span></code></pre></div><p>Then:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout feature-b
</span></span><span style=display:flex><span>git rebase feature-a
</span></span><span style=display:flex><span>git push --force-with-lease origin feature-b
</span></span></code></pre></div><p>Then:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout feature-c
</span></span><span style=display:flex><span>git rebase feature-b
</span></span><span style=display:flex><span>git push --force-with-lease origin feature-c
</span></span></code></pre></div><p>This way, all three branches now sit on top of the latest upstream/main, and their dependency chain is preserved cleanly.</p><p>If you do this in reverse (rebase feature-c before feature-a), the history will break and conflicts will be harder to fix.</p><h2></h2><h2 id=step-16-how-to-split-a-large-feature-branch-into-multiple-pull-requests-using-cherry-pick-or-stacking>Step 16: How to split a large feature branch into multiple pull requests using cherry-pick or stacking</h2><p>Suppose you created a massive branch called feature/huge with 30 commits, but now the team wants smaller, reviewable pull requests. You don&rsquo;t want to dump all 30 commits in one PR.</p><p>You can split this using two approaches:</p><h3 id=approach-a-stacking-branches-cleaner>Approach A: Stacking branches (cleaner)</h3><ol><li>Start by checking out the base branch:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout main
</span></span></code></pre></div></li><li>Create a new branch for the first logical chunk:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b feature/part1
</span></span></code></pre></div></li><li>Use interactive rebase to split commits:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase -i feature/huge
</span></span></code></pre></div>In the interactive menu, pick only the commits relevant to part 1, and drop or skip the rest.</li><li>Push part 1:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin feature/part1
</span></span></code></pre></div></li><li>Create a new branch for part 2, based on part 1:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b feature/part2
</span></span></code></pre></div></li><li>Cherry-pick the next group of commits from feature/huge:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git cherry-pick &lt;commit1&gt; &lt;commit2&gt; ...
</span></span></code></pre></div></li></ol><p>Repeat this for as many parts as needed. Each feature/partN becomes a separate PR, and each one is based on the previous.</p><p>This is called stacked PRs, where each branch builds on the previous one.</p><h3 id=approach-b-cherry-pick-into-multiple-independent-branches>Approach B: Cherry-pick into multiple independent branches</h3><p>If the parts are truly unrelated, you can skip stacking and do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout main
</span></span><span style=display:flex><span>git checkout -b part-a
</span></span><span style=display:flex><span>git cherry-pick &lt;commit1&gt; &lt;commit2&gt;
</span></span><span style=display:flex><span>git push origin part-a
</span></span></code></pre></div><p>Then:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout main
</span></span><span style=display:flex><span>git checkout -b part-b
</span></span><span style=display:flex><span>git cherry-pick &lt;commit3&gt; &lt;commit4&gt;
</span></span><span style=display:flex><span>git push origin part-b
</span></span></code></pre></div><p>Now each part is a separate branch, independent of each other. You can raise separate PRs against main.</p><p>Use this only if the commits don&rsquo;t depend on each other. Otherwise, prefer the stacked model.</p><h2></h2><h2 id=step-17-how-to-rewrite-commit-history-using-git-rebase--i-interactive-rebase>Step 17: How to rewrite commit history using git rebase -i (interactive rebase)</h2><p>This is used to clean up your branch before pushing or raising a PR - especially if the history has noisy commits like &ldquo;fix typo&rdquo;, &ldquo;debug print&rdquo;, &ldquo;oops&rdquo;, etc.</p><p>Say your branch has 6 commits on top of main:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>main
</span></span><span style=display:flex><span>  └── Commit A
</span></span><span style=display:flex><span>      └── Commit B
</span></span><span style=display:flex><span>          └── Commit C
</span></span><span style=display:flex><span>              └── Commit D
</span></span><span style=display:flex><span>                  └── Commit E
</span></span><span style=display:flex><span>                      └── Commit F   ← HEAD
</span></span></code></pre></div><p>Now you want to:</p><ul><li>Combine related commits (squash)</li><li>Rename some commit messages (reword)</li><li>Remove junk commits (drop)</li><li>Merge tiny fixes into earlier commits (fixup)</li><li>Rearrange the commit order (reorder)</li></ul><p>You run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase -i main
</span></span></code></pre></div><p>This opens an editor with a list of commits in reverse order (latest first):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pick <span style=color:#ae81ff>123456</span> Commit F
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>234567</span> Commit E
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>345678</span> Commit D
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>456789</span> Commit C
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>567890</span> Commit B
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>678901</span> Commit A
</span></span></code></pre></div><p>Now you can replace the word pick with:</p><ul><li>squash - combine this commit with the one above and edit the message</li><li>fixup - combine silently (no new commit message)</li><li>reword - keep commit, change its message</li><li>drop - delete this commit</li><li>move lines up/down to reorder commits</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>reword <span style=color:#ae81ff>678901</span> Initial commit
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>567890</span> Add login form
</span></span><span style=display:flex><span>squash <span style=color:#ae81ff>456789</span> Fix login CSS
</span></span><span style=display:flex><span>pick <span style=color:#ae81ff>345678</span> Add logout logic
</span></span><span style=display:flex><span>drop <span style=color:#ae81ff>234567</span> Console.log debug
</span></span></code></pre></div><p>After saving, Git replays the commits one by one as per your instructions. If conflicts occur, you fix and continue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase --continue
</span></span></code></pre></div><p>If you want to abort:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase --abort
</span></span></code></pre></div><p>When done, your branch history is rewritten, clean, compact, and well-labeled.</p><p>If the branch is already pushed, you will need to force-push:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push --force origin your-branch
</span></span></code></pre></div><p>Use this only on branches you control, not shared ones.</p><h2></h2><h2 id=step-18-how-to-undo-mistakes-using-reflog-reset-and-restore>Step 18: How to undo mistakes using reflog, reset, and restore</h2><p>Git never forgets anything immediately. Most mistakes can be reversed safely.</p><h3 id=a-git-reflog-recover-any-previous-state>A. <code>git reflog</code>: recover any previous state</h3><p>Git logs every position your HEAD has pointed to - even after rebases, resets, etc.</p><p>Run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reflog
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>a1b2c3d HEAD@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>: rebase: updated feature-x
</span></span><span style=display:flex><span>f6e7d8c HEAD@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>: checkout main
</span></span><span style=display:flex><span>89ab123 HEAD@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>: commit: fix bug in handler
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>This means: even if you messed up and lost commits, you can go back to any earlier state.</p><p>To recover:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --hard HEAD@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Or to branch off from there:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b rescue HEAD@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=b-git-reset-move-branches>B. <code>git reset</code>: move branches</h3><p>Used to move the current branch pointer to some other commit.</p><ul><li>Soft: move pointer only, keep files/changes staged<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --soft HEAD~2
</span></span></code></pre></div></li><li>Mixed: move pointer, keep files in working directory but unstage them<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --mixed HEAD~2
</span></span></code></pre></div></li><li>Hard: move pointer and erase all changes<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --hard HEAD~2
</span></span></code></pre></div></li></ul><p>Only use <code>--hard</code> if you are 100% sure you want to discard changes.</p><h3 id=c-git-restore-recover-or-discard-files-working-tree-level>C. <code>git restore</code>: recover or discard files (working tree level)</h3><ul><li>To discard local changes to a file:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git restore somefile.java
</span></span></code></pre></div></li><li>To restore a deleted file:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git restore --staged --worktree somefile.java
</span></span></code></pre></div></li><li>To unstage a file (after git add but before commit):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git restore --staged file.txt
</span></span></code></pre></div></li></ul><p>This is safer than reset for touching files without touching the branch pointer.</p><h2></h2><h2 id=step-19-how-to-properly-delete-local-and-remote-branches>Step 19: How to properly delete local and remote branches</h2><p>Branches are cheap in Git, but they pile up fast. Once a branch is merged or no longer needed, it should be deleted - locally and remotely - to keep things clean.</p><h3 id=deleting-a-local-branch>Deleting a local branch</h3><p>List local branches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch
</span></span></code></pre></div><p>To delete a local branch (e.g. <code>feature/foo</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch -d feature/foo
</span></span></code></pre></div><p>This only works if the branch is fully merged. If not, Git will block the deletion.</p><p>To delete forcefully (even if not merged):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch -D feature/foo
</span></span></code></pre></div><p>This removes the reference from <code>.git/refs/heads/feature/foo</code>. It does not affect remotes.</p><h3 id=deleting-a-remote-branch>Deleting a remote branch</h3><p>To delete a branch from the remote (e.g. from origin):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin --delete feature/foo
</span></span></code></pre></div><p>This sends an explicit delete instruction to the remote. On GitHub, the branch will disappear from the branch list and PR dropdowns.</p><p>You can confirm by fetching and listing remote branches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch -p
</span></span><span style=display:flex><span>git branch -r
</span></span></code></pre></div><p>Note: <code>-p</code> (prune) removes stale remote-tracking references like <code>origin/feature/foo</code> if the remote branch was deleted.</p><h2></h2><h2 id=step-20-how-to-deal-with-diverged-branches-and-safely-force-push>Step 20: How to deal with diverged branches and safely force-push</h2><p>Sometimes you try to push and Git says:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>! <span style=color:#f92672>[</span>rejected<span style=color:#f92672>]</span>        main -&gt; main <span style=color:#f92672>(</span>non-fast-forward<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error: failed to push some refs to ...
</span></span><span style=display:flex><span>hint: Updates were rejected because the remote contains work that you <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>hint: not have locally.
</span></span></code></pre></div><p>This means:</p><ul><li>Your local branch and the remote branch have both moved forward, but in different directions</li><li>Git cannot safely push without losing commits from the remote</li></ul><p>This is called a diverged branch</p><h3 id=option-1-first-pull-then-push>Option 1: First pull, then push</h3><p>The safe approach is to bring in the remote changes first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git pull --rebase
</span></span></code></pre></div><p>This replays your local commits on top of the remote&rsquo;s latest state. Then push:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push
</span></span></code></pre></div><p>This avoids merge commits and keeps a linear history.</p><h3 id=option-2-force-push-if-your-local-branch-is-correct>Option 2: Force push if your local branch is correct</h3><p>If you intentionally rewrote history (e.g. interactive rebase) and you know your branch is the new correct version, force push it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push --force origin branchname
</span></span></code></pre></div><p>This will overwrite the branch on the remote with your local version. Use this only if:</p><ul><li>You&rsquo;re working on your own fork or a private feature branch</li><li>Nobody else is depending on that branch</li></ul><p>If others are using it, coordinate before forcing.</p><h3 id=option-3-overwrite-your-local-branch-with-remote-discard-local-changes>Option 3: Overwrite your local branch with remote (discard local changes)</h3><p>If your local branch is wrong and you want to reset it to match the remote exactly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch origin
</span></span><span style=display:flex><span>git reset --hard origin/branchname
</span></span></code></pre></div><p>This deletes all local commits and makes your branch identical to the remote.</p><h2></h2><h2 id=git-commands-summary>Git Commands Summary</h2><table><thead><tr><th>Task</th><th>Command</th></tr></thead><tbody><tr><td>Clone a repo</td><td><code>git clone &lt;url></code></td></tr><tr><td>View remotes</td><td><code>git remote -v</code></td></tr><tr><td>Add upstream remote</td><td><code>git remote add upstream &lt;url></code></td></tr><tr><td>Fetch all remotes</td><td><code>git fetch</code> / <code>git fetch upstream</code></td></tr><tr><td>See local/remote branches</td><td><code>git branch</code> / <code>git branch -r</code></td></tr><tr><td>Set tracking branch</td><td><code>git branch --set-upstream-to=origin/dev dev</code></td></tr><tr><td>Pull with merge</td><td><code>git pull</code></td></tr><tr><td>Pull with rebase</td><td><code>git pull --rebase</code></td></tr><tr><td>Merge remote into local</td><td><code>git merge origin/main</code></td></tr><tr><td>Rebase onto remote</td><td><code>git rebase origin/main</code></td></tr><tr><td>Rebase feature branch on upstream</td><td><code>git rebase upstream/main</code></td></tr><tr><td>Push to origin</td><td><code>git push origin branchname</code></td></tr><tr><td>Force push after rebase</td><td><code>git push --force origin branchname</code></td></tr><tr><td>Cherry-pick specific commits</td><td><code>git cherry-pick &lt;commit></code></td></tr><tr><td>Interactive rebase (rewrite history)</td><td><code>git rebase -i main</code></td></tr><tr><td>Delete local/remote branch</td><td><code>git branch -d name</code> / <code>git push origin --delete</code></td></tr><tr><td>Undo via reflog</td><td><code>git reflog</code>, <code>git reset --hard HEAD@{n}</code></td></tr><tr><td>Discard local changes</td><td><code>git restore &lt;file></code> / <code>git reset --hard</code></td></tr><tr><td>Fix diverged push</td><td><code>git pull --rebase</code> / <code>git push --force</code></td></tr></tbody></table></div></article></main><script async src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js defer></script></body></html>