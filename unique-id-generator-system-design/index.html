<!doctype html><html lang=hi><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wdth,wght@0,75..100,100..900;1,75..100,100..900&display=swap" rel=stylesheet><link rel=stylesheet href=https://csetutorials.com/scss/main.min.css><title>Unique ID generator in distributed systems</title>
<meta name=description content="Unique ID geneator system design key points to remember"><meta name=author content="Ashish Doneriya"><meta name=robots content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><link rel=canonical href=https://csetutorials.com/unique-id-generator-system-design/><meta property="og:type" content="article"><meta property="og:title" content="Unique ID generator in distributed systems"><meta property="og:description" content="Unique ID geneator system design key points to remember"><meta name=keywords content="snowflake,uuid"><meta property="og:url" content="https://csetutorials.com/unique-id-generator-system-design/"><meta property="og:site_name" content="Cse Tutorials"><meta property="article:published_time" content="2021-03-25T02:30:00+05:30"><meta property="article:modified_time" content="2021-03-25T02:30:00+05:30"><meta property="article:author" content="Ashish Doneriya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Unique ID generator in distributed systems"><meta name=twitter:description content="Unique ID geneator system design key points to remember"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Unique ID generator in distributed systems","description":"Unique ID geneator system design key points to remember","author":{"@type":"Person","name":"Ashish Doneriya"},"keywords":["\"%!s(MISSING)\", \"%!s(MISSING)\""],"articleSection":["\"%!s(MISSING)\""],"datePublished":"2021-03-25T02:30:00\u002b05:30","dateModified":"2021-03-25T02:30:00\u002b05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/csetutorials.com\/unique-id-generator-system-design\/"},"url":"https:\/\/csetutorials.com\/unique-id-generator-system-design\/"}</script></head><body style=background-color:#f9f9f9;font-family:roboto,sans-serif><nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class=container><a class=navbar-brand href=/>Cse Tutorials</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-end" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/about-us/>About us</a></li><li class=nav-item><a class=nav-link href=/contact-us/>Contact us</a></li><li class=nav-item><a class=nav-link href=/privacy-policy/>Privacy Policy</a></li><li class=nav-item><a class=nav-link href=/terms-of-service/>Terms of Service</a></li><li class=nav-item><a class=nav-link href>Topics</a></li></ul></div></div></nav><main><article class=page-wrapper><h1 class="mb-4 text-center">Unique ID generator in distributed systems</h1><div class="d-flex justify-content-center align-items-center mb-4 text-muted small"><time datetime="2021-03-25 02:30:00 +0530 +0530">Mar 25, 2021</time>
<span class=mx-2>|</span>
<span>Ashish Doneriya</span>
<span class=mx-2>|</span>
<a class=text-decoration-none href=/topics/system-design rel=category>System Design</a></div><div class=post-content><h2 id=key-points>Key Points</h2><ul><li><p>MySQL auto increment is not sufficient for distributed systems because it is not large enough & would be very challenging generating unique ids across multiple databases with minimal delay;</p></li><li><p>Our requirement is the ids should be unique, sortable, max 64 bit (8 bytes ie. could fit in long data type in Java).</p></li></ul><h2 id=three-ways-using-which-we-can-generate><strong>Three ways using which we can generate</strong></h2><h3 id=uuid>UUID</h3><ul><li>UUID is 128 bit.</li><li>It has very low probability of collusion.</li><li>It could be generated without coordinated servers.</li><li>It has drawback that is the ids could be non numeric.</li><li>Since our requirement is 64 bits, therefore UUIDs won&rsquo;t be able to satisfy our requirements</li></ul><h3 id=ticket-server>Ticket Server</h3><ul><li><a href=https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/ target=_blank rel="noopener nofollow">Flickr</a> developed this technique.</li><li>There is a dedicated mysql server database which is used to generate keys.</li><li>All the other servers hit mysql to get the unique keys.</li><li>This approach has drawback. It has single point of failure. In case of that single mysql server machine goes down, the entire system would fail.</li><li>The webservers would hit the below sql command to get the unique key.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>INTO</span> Tickets64 (stub) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;a&#39;</span>);<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>from</span> Tickets64;
</span></span></code></pre></div>The table creating syntax is -<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>Tickets64<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> bigint(<span style=color:#ae81ff>20</span>) unsigned <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>stub<span style=color:#f92672>`</span> char(<span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>stub<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>stub<span style=color:#f92672>`</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB
</span></span></code></pre></div></li></ul><h3 id=twitter-snowflake>Twitter Snowflake</h3><p>Twitter snowflake IDs are 64-bit. In this approach the ID is divided into multiple parts -</p><ul><li>1 bit - <strong>reserved</strong></li><li>41 bit - <strong>for storing timestamp</strong> epoch. Instead of storing milliseconds since 1 January 1970, we will start from 4 Nov 2010 01:42:54 UTC (1288834974657) that is twitter snowflake default epoch.</li><li>5 bit - <strong>data center id</strong>. Maximum 2^5 = 32 datacenters.</li><li>5 bit - <strong>machine id</strong>. Maximum 2^5=32 machines per datacenter. This means not every webserver could generate its own key individualy. There has to be a dedicated id generator (distributed key generator).</li><li>12 bits - <strong>sequence number</strong>. For every request the number gets increased. After every millisecond the number resets to 0.</li></ul><p>This id generator would work for around 70 years (if we include that starting 1 bit also). We will put a <strong>load balancer</strong> in this architecture to divide the traffic equally among all servers using round robin. If we want to divide the traffic based on the machine capacity then we could add <a href=/consistent-hashing-design-techniques.html>virtual nodes</a> also.</p><h3 id=sonyflake>Sonyflake</h3><p>A Sonyflake ID is composed of -</p><ul><li>39 bits for time in units of 10 msec</li><li>8 bits for a sequence number</li><li>16 bits for a machine id</li></ul><p>As a result, Sonyflake has the following advantages and disadvantages -</p><ul><li>The lifetime (174 years) is longer than that of Snowflake (69 years)</li><li>It can work in more distributed machines (2^16) than Snowflake (2^10)</li><li>It can generate 2^8 IDs per 10 msec at most in a single machine/thread (slower than Snowflake)</li></ul><h3 id=my-approach>My Approach</h3><ul><li>The key would be of 64-bit.</li><li>We know that there could be 2^40 keys in 64-bit (ie 9 billion billion).</li><li>In this architecture there are two types of key servers - Main Key Servers (very small in number ie less than 10) & Worker Key Servers ( could be many but limited)</li><li>When the request comes to worker key server for getting a key, the worker key server would ask the main key server to allocate the worker key server a range of keys.</li><li>Then the main key server allocates that worker key server 1 million range. Lets say the main key server will tell the worker key server ok you could use keys between 180 million to 181 million minus one keys.</li><li>After giving the key range, the main server will update the range to a persistent db/disk. ie. it would store information that it has allocated 181 keys till now.</li><li>When a new request comes from worker key server to main key server, the main key server would allocate it 181 million to 182 million keys. ie 1 million keys for each new request.</li><li>The main key server(s) would handle the requests in a synchronized way ie. one by one. In case of multiple threads it could ask another set of values for each thread.</li><li>After receiving the keys range from the main key server, the worker key server will distribute the keys in synchronized way. When the limit gets exhausted, the worker key server will again fetch the key ranges from main key server. In case of machine failure the respawned machine will continue after receiving a new set of keys from main server.</li><li>We will put 2 load balances - one for main key servers and another for worker key servers to distribute the traffic.</li><li>This system can be replicated in multiple data centers ie. in every data center there could be a set of main key servers and worker key servers.</li></ul><h2 id=calculation>Calculation</h2><ul><li>We would assign a set of key range for each data center ( hard coded ).</li><li>Lets suppose there are 200 data centers ( 50 data centers at present, 150 reserved for future).</li><li>So 2^ 40 / 200 = 46116 trillion keys for each data center.</li><li>Since each time a worker take a range of 1 million keys. So it would take around 46 billion requests to exhaust the datacenter keys range which is I think would be sufficient.</li><li>You can change numbers ( ie. no. of data centers, key range etc.) according to your requirements.</li></ul></div></article></main><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js defer></script></body></html>